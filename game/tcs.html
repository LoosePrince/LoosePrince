<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
		<title>è´ªåƒè›‡å¤§å†’é™©</title>
		<link href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css" rel="stylesheet">
		<!-- åœ¨çº¿å¼•å…¥Reactã€ReactDOMã€Babel -->
		<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
		<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		<!-- åœ¨çº¿å¼•å…¥Tailwind CSS -->
		<script src="https://cdn.tailwindcss.com"></script>
		<!-- åœ¨çº¿å¼•å…¥Font Awesomeå›¾æ ‡åº“ -->
		<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
		<style>
		    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap');
		    
		    * {
		        margin: 0;
		        padding: 0;
		        box-sizing: border-box;
		    }

		    body {
		        font-family: 'Noto Sans SC', sans-serif;
		        background: linear-gradient(135deg, #ff9a9e 0%, #fecfef 50%, #fecfef 100%);
		        min-height: 100vh;
		        height: 100vh;
		        display: flex;
		        flex-direction: column;
		        align-items: center;
		        padding: 10px;
		        color: #5a5a5a;
		    }
		</style>
		<script>
		    // é…ç½®Tailwindè‡ªå®šä¹‰é¢œè‰²ï¼Œç”¨äºæ¸¸æˆå…ƒç´ çš„æ ·å¼
		    tailwind.config = {
		        theme: {
		            extend: {
		                colors: {
		                    snake: {
		                        body: '#10B981',    // è›‡èº«ä½“é¢œè‰²(ç»¿è‰²)
		                        head: '#059669',    // è›‡å¤´é¢œè‰²(æ·±ç»¿è‰²)
		                        food: '#EF4444',    // æ™®é€šé£Ÿç‰©é¢œè‰²(çº¢è‰²)
		                        grid: '#E5E7EB',    // ç½‘æ ¼çº¿é¢œè‰²(æµ…ç°è‰²)
		                        background: '#F9FAFB' // æ¸¸æˆèƒŒæ™¯è‰²
		                    }
		                }
		            }
		        }
		    }

		</script>
		<script>		    
		    // å®Œå…¨é˜»æ­¢æ‰‹æœºæµè§ˆå™¨ä¸‹æ»‘åˆ·æ–°å’Œæ»šåŠ¨
		    (function() {
		        // å®Œå…¨é˜»æ­¢æ‰€æœ‰è§¦æ‘¸ç§»åŠ¨äº‹ä»¶
		        document.addEventListener('touchmove', function(e) {
		            e.preventDefault();
		        }, { passive: false });
		        
		        // é˜»æ­¢è§¦æ‘¸å¼€å§‹äº‹ä»¶ï¼ˆé˜²æ­¢æ»šåŠ¨ï¼‰
		        document.addEventListener('touchstart', function(e) {
		            // å…è®¸æŒ‰é’®ã€æ¸¸æˆåŒºåŸŸå’Œæ¸¸æˆæ§åˆ¶çš„è§¦æ‘¸
		            if (e.target.tagName === 'BUTTON' || e.target.closest('button') || 
		                e.target.closest('.game-grid') || e.target.closest('.game-controls')) {
		                return;
		            }
		            // å…¶ä»–åŒºåŸŸé˜»æ­¢é»˜è®¤è¡Œä¸º
		            e.preventDefault();
		        }, { passive: false });
		        
		        // é˜»æ­¢è§¦æ‘¸ç»“æŸäº‹ä»¶
		        document.addEventListener('touchend', function(e) {
		            // å…è®¸æŒ‰é’®ã€æ¸¸æˆåŒºåŸŸå’Œæ¸¸æˆæ§åˆ¶çš„è§¦æ‘¸
		            if (e.target.tagName === 'BUTTON' || e.target.closest('button') || 
		                e.target.closest('.game-grid') || e.target.closest('.game-controls')) {
		                return;
		            }
		            e.preventDefault();
		        }, { passive: false });
		        
		        // é˜»æ­¢åŒå‡»ç¼©æ”¾
		        let lastTouchEnd = 0;
		        document.addEventListener('touchend', function(e) {
		            const now = (new Date()).getTime();
		            if (now - lastTouchEnd <= 300) {
		                // å…è®¸æŒ‰é’®çš„åŒå‡»
		                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
		                    return;
		                }
		                e.preventDefault();
		            }
		            lastTouchEnd = now;
		        }, false);
		        
		        // é˜»æ­¢é•¿æŒ‰èœå•
		        document.addEventListener('contextmenu', function(e) {
		            e.preventDefault();
		        });
		        
		        // é˜»æ­¢é¼ æ ‡æ»šè½®äº‹ä»¶
		        document.addEventListener('wheel', function(e) {
		            e.preventDefault();
		        }, { passive: false });
		        
		        // é˜»æ­¢é”®ç›˜æ»šåŠ¨ï¼ˆä½†ä¿ç•™æ¸¸æˆæ§åˆ¶ï¼‰
		        document.addEventListener('keydown', function(e) {
		            // é˜»æ­¢æ»šåŠ¨ç›¸å…³çš„æŒ‰é”®ï¼Œä½†ä¿ç•™æ¸¸æˆæ§åˆ¶æŒ‰é”®
		            if ([33, 34, 35, 36].indexOf(e.keyCode) > -1) {
		                // 33: Page Up, 34: Page Down, 35: End, 36: Home
		                e.preventDefault();
		            }
		            // æ³¨æ„ï¼šæ–¹å‘é”®(37-40)ã€ç©ºæ ¼é”®(32)å’ŒWASDé”®ä¿ç•™ç”¨äºæ¸¸æˆæ§åˆ¶
		        });
		        
		    })();
		</script>
		<style type="text/tailwindcss">
		    @layer utilities {
		        /* æ¸¸æˆå®¹å™¨æ ·å¼ */
		        .game-container {
		            background: rgba(255, 255, 255, 0.95);
		            border-radius: 20px;
		            padding: 15px;
		            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
		            backdrop-filter: blur(10px);
		            border: 2px solid rgba(255, 182, 193, 0.3);
					max-width: calc(100vw - 40px);
		            width: 400px;
		            max-height: calc(100vh - 40px);
		            overflow: hidden;
		            display: flex;
		            flex-direction: column;
		        }
		        
		        /* æ¸¸æˆç½‘æ ¼å®¹å™¨æ ·å¼ */
		        .game-grid {
		            @apply relative w-full
					mx-auto aspect-square bg-snake-background 
					border-4 border-gray-700 rounded-lg overflow-hidden;
		        }
		        /* ç½‘æ ¼å•å…ƒæ ¼æ ·å¼ */
		        .grid-cell {
		            @apply absolute border border-snake-grid/30;
		        }
		        /* è›‡èº«ä½“éƒ¨åˆ†æ ·å¼ */
		        .snake-segment {
		            @apply absolute bg-snake-body rounded-sm transition-all duration-100;
		        }
		        /* è›‡å¤´æ ·å¼ */
		        .snake-head {
		            @apply bg-snake-head;
		        }
		        /* æ™®é€šé£Ÿç‰©æ ·å¼ */
		        .food {
		            @apply absolute bg-snake-food rounded-full transition-all duration-200 animate-pulse;
		        }
		        /* å¥–åŠ±é£Ÿç‰©æ ·å¼ */
		        .bonus-food {
		            @apply absolute bg-purple-600 rounded-full transition-all duration-200 animate-pulse;
		        }
		        
		        /* æ ‡é¢˜æ ·å¼ */
		        .game-title {
		            font-size: 1.8rem;
		            font-weight: 700;
		            color: #ff6b6b;
		            text-shadow: 0 2px 10px rgba(255, 107, 107, 0.3);
		            margin-bottom: 5px;
		            text-align: center;
		        }
		        
		        .game-subtitle {
		            font-size: 0.9rem;
		            color: #666;
		            font-weight: 300;
		            text-align: center;
		            margin-bottom: 10px;
		        }
		        
		        /* çŠ¶æ€é¢æ¿æ ·å¼ */
		        .status-panel {
		            background: rgba(255, 255, 255, 0.9);
		            border-radius: 15px;
		            padding: 10px;
		            margin: 10px 0;
		            text-align: center;
		            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
		            backdrop-filter: blur(10px);
		            border: 2px solid rgba(255, 182, 193, 0.3);
		        }
		        
		        /* æŒ‰é’®æ ·å¼ */
		        .game-btn {
		            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
		            color: white;
		            border: none;
		            padding: 8px 16px;
		            border-radius: 20px;
		            font-size: 0.9rem;
		            font-weight: 600;
		            cursor: pointer;
		            transition: all 0.3s ease;
		            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
		        }
		        
		        .game-btn:hover {
		            transform: translateY(-2px);
		            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.4);
		        }
		        
		        
		    }
		</style>
	</head>
	<body>
		<!-- æ¸¸æˆæŒ‚è½½ç‚¹ -->
		<div id="root"></div>
		<script type="text/babel">
			const {useState, useEffect, useCallback} = React;
			// æ¸¸æˆçŠ¶æ€
			const GameStatus = ({score, highScore, speedLevel, isTemporarySpeed}) => {
				return (
					<div className="status-panel">
						<div className="flex flex-wrap justify-between items-center gap-4">
							<div className="text-center">
								<h3 className="text-gray-700 font-bold text-lg">æ¸¸æˆåˆ†æ•°</h3>
								<p className="text-2xl font-bold text-snake-head">{score}</p>
							</div>
							<div className="text-center">
								<h3 className="text-gray-700 font-bold text-lg">æœ€é«˜å¾—åˆ†</h3>
								<p className="text-2xl font-bold text-snake-head">{highScore}</p>
							</div>
							<div className="text-center">
								<h3 className="text-gray-700 font-bold text-lg">é€Ÿåº¦ç­‰çº§</h3>
								<p className={`text-2xl font-bold ${isTemporarySpeed ? 'text-yellow-500 animate-pulse' : 'text-snake-head'}`}>
									{speedLevel}
									{isTemporarySpeed && <span className="text-sm ml-1">âš¡</span>}
								</p>
							</div>
						</div>
					</div>
				)
			}
			
			// ç½‘æ ¼å•å…ƒæ ¼
			const GridCell = ({position, size}) => {
				return (
					<div
						className="grid-cell"
						style={{
							left: `${position.x * size}%`,
							top: `${position.y * size}%`,
							width: `${size}%`,
							height: `${size}%`,
						}}
					></div>
				)
			}

			// è›‡èº«ä½“éƒ¨åˆ†
			const SnakeSegment = ({position, size, isHead}) => {
				return (
					<div className={`snake-segment ${isHead ? 'snake-head' : ''}`}
						style={{
							left: `${position.x * size}%`,
							top: `${position.y * size}%`,
							width: `${size}%`,
							height: `${size}%`,
						}}
					></div>
				)
			}

			// é£Ÿç‰©
			const Food = ({position, size, isBonus}) => {
				return (
					<div 
						className={isBonus ? 'bonus-food' : 'food'}
						style={{
							left: `${position.x * size}%`,
							top: `${position.y * size}%`,
							width: `${size * 0.8}%`,
							height: `${size * 0.8}%`,
							margin: `${size * 0.1}%`,
						}}
					></div>
				)
			}

			// æ¸¸æˆæ§åˆ¶
			const GameControls = ({isPlay, onStart, onPause, onResume}) => {
				if (!isPlay) {
					return (
						<button 
							onClick={onStart} 
							className="game-btn"
						>
							<i className="fas fa-play mr-1"></i>å¼€å§‹
						</button>
					)
				}
				return (
					<div className="flex justify-center items-center gap-2">
						<button 
							onClick={onPause} 
							className="game-btn"
						>
							<i className="fas fa-pause mr-1"></i>æš‚åœ
						</button>
						<button 
							onClick={onResume} 
							className="game-btn"
						>
							<i className="fas fa-play mr-1"></i>ç»§ç»­
						</button>
					</div>
				)
			}

			// æ¸¸æˆç»“æŸæ¨¡æ€æ¡†
			const GameOverModal = ({score, highScore, onRestart}) => {
				return (
					<div className="fixed inset-0 bg-black/60 flex justify-center items-center z-50 p-2">
						<div className="bg-white rounded-2xl shadow-2xl p-4 max-w-sm w-full text-center">
							<div className="mb-3 text-4xl text-snake-food"><i className="fa fa-times-circle"></i></div>
							<h2 className="text-2xl font-bold text-gray-800 mb-2">æ¸¸æˆç»“æŸ</h2>
							<p className="text-lg mb-1">å¾—åˆ†ï¼š<span className="text-snake-head font-bold">{score}</span></p>
							<p className="text-lg mb-3">æœ€é«˜ï¼š<span className="text-snake-head font-bold">{highScore}</span></p>
							<button onClick={onRestart} className="game-btn w-full">
								<i className="fas fa-play mr-1"></i>é‡æ–°å¼€å§‹
							</button>
						</div>
					</div>
				)
			}

			// è´ªåƒè›‡æ¸¸æˆ
			const SnakeGame = () => {
				const GRID_SIZE = 20;
				const CELL_SIZE = 100/GRID_SIZE;
				const [snake, setSnake] = useState([
					{x: 10, y: 10},
					{x: 9, y: 10},
					{x: 8, y: 10},
				]);
				const [direction, setDirection] = useState({x: 1 ,y: 0});
				const [nextDirection, setNextDirection] = useState({x: 1 ,y: 0});
				const [food, setFood] = useState({x: 15, y: 10});
				const [bonusFood, setBonusFood] = useState(null); // å¥–åŠ±é£Ÿç‰©
				const [score, setScore] = useState(0); // æ¸¸æˆåˆ†æ•°
				const [highScore, setHighScore] = useState(localStorage.getItem('snakeHighScore') || 0);
				const [isPlay, setIsPlay] = useState(false); // æ¸¸æˆæ˜¯å¦å¼€å§‹
				const [isPaused, setIsPaused] = useState(false); // æ¸¸æˆæ˜¯å¦æš‚åœ
				const [gameOver, setGameOver] = useState(false); // æ¸¸æˆæ˜¯å¦ç»“æŸ
				const [gameSpeed, setGameSpeed] = useState(400); // æ¸¸æˆé€Ÿåº¦
				const [speedLevel, setSpeedLevel] = useState(1);
				const [lastMoveTime, setLastMoveTime] = useState(0); // ä¸Šæ¬¡ç§»åŠ¨æ—¶é—´

				// ç”Ÿæˆé£Ÿç‰©
				const genFood = () => {
					let newPosition;
					do {
						newPosition = {
							x: Math.floor(Math.random() * GRID_SIZE),
							y: Math.floor(Math.random() * GRID_SIZE),
						}
					} while (snake.some(segment => segment.x === newPosition.x && segment.y === newPosition.y));
					return newPosition;
				}

				// å¼€å§‹æ¸¸æˆ
				const startGame = () => {
					setSnake([
						{x: 10, y: 10},
						{x: 9, y: 10},
						{x: 8, y: 10},
					])
					setDirection({x: 1, y: 0});
					setNextDirection({x: 1, y: 0});
					setFood(genFood());
					setBonusFood(null);
					setScore(0);
					setIsPlay(true);
					setIsPaused(true);
					setGameOver(false);
					setGameSpeed(200);
					setSpeedLevel(1);
					setLastMoveTime(Date.now()); // åˆå§‹åŒ–ç§»åŠ¨æ—¶é—´
				}

				// æš‚åœæ¸¸æˆ
				const pauseGame = () => {
					setIsPaused(true);
				}

				// ç»§ç»­æ¸¸æˆ
				const resumeGame = () => {
					setIsPaused(false);
				}

				// æ¸¸æˆç»“æŸ
				const endGame = () => {
					setIsPlay(false);
					setGameOver(true);
					setHighScore(prev => {
						const newHigh = Math.max(Number(prev) || 0, score);
						localStorage.setItem('snakeHighScore', newHigh);
						return newHigh;
					});
				}

				// é‡æ–°å¼€å§‹æ¸¸æˆ
				const restartGame = () => {
					startGame();
				}

				// æ¸²æŸ“ç½‘æ ¼å‡½æ•°
				const renderGrid = () => {
					const cells = [];
					for (let x = 0; x < GRID_SIZE; x++) {
						for (let y = 0; y < GRID_SIZE; y++) {
							cells.push(
								<GridCell 
									key={`${x}-${y}`}
									position={{x, y}} 
									size={CELL_SIZE} 
								/>
							);
						}
					}
					return cells;
				};

				// å¢åŠ é€Ÿåº¦
				const increaseSpeed = (level) => {
					level = Math.min(Math.floor(level), 20); // å–æ•´
					setSpeedLevel(prev => level);
					setGameSpeed(prev => 200 - 10 * level); // æ¯çº§å‡å°‘10ms
				}

				// ç§»åŠ¨è›‡
				const moveSnake = useCallback(() => {
					if (!isPlay || isPaused || gameOver) return;
					
					const currentTime = Date.now();
					
					// åº”ç”¨ä¸‹ä¸€å¸§æ–¹å‘
					setDirection(prev => nextDirection);
					const head = {
						y: snake[0].y + nextDirection.y,
						x: snake[0].x + nextDirection.x,
					}
					
					// æ£€æŸ¥æ˜¯å¦æ’å¢™æˆ–æ’åˆ°è‡ªå·±
					const hitWall = head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE;
					const hitSelf = snake.some(segment => segment.x === head.x && segment.y === head.y);
					
					// å¦‚æœå‘ç”Ÿç¢°æ’ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨500æ¯«ç§’å†…å¯ä»¥è½¬å‘
					if (hitWall || hitSelf) {
						// å¦‚æœè·ç¦»ä¸Šæ¬¡ç§»åŠ¨è¶…è¿‡500æ¯«ç§’ï¼Œåˆ™æ¸¸æˆç»“æŸ
						if (currentTime - lastMoveTime >= 500) {
							endGame();
							return;
						}
						// å¦‚æœåœ¨500æ¯«ç§’å†…ï¼Œå…è®¸è½¬å‘ï¼Œä¸ç§»åŠ¨è›‡
						return;
					}
					
					// æ›´æ–°ç§»åŠ¨æ—¶é—´
					setLastMoveTime(currentTime);
					
					const ateFood = head.x === food.x && head.y === food.y;
					const ateBonusFood = bonusFood && head.x === bonusFood.x && head.y === bonusFood.y;
					let newSnake ;
					if (ateFood || ateBonusFood) {
						newSnake = [head, ...snake];
						if (ateFood) {
							setFood(genFood());
							setScore(prev => prev + 10);
						} else {
							setBonusFood(null);
							setScore(prev => prev + 50);
						}
					} else {
						newSnake = [head, ...snake.slice(0, -1)];
					}
					setSnake(newSnake);
				}, [isPlay, isPaused, gameOver, nextDirection, snake, food, bonusFood, lastMoveTime])
				
				// ä¸´æ—¶åŠ é€ŸçŠ¶æ€
				const [isTemporarySpeed, setIsTemporarySpeed] = useState(false);
				const [speedTimeout, setSpeedTimeout] = useState(null);

				// æ–¹å‘æ§åˆ¶å‡½æ•°
				const handleDirectionChange = (newDirection) => {
					if (
						(newDirection.x !== direction.x || newDirection.y !== direction.y) &&
						!(newDirection.x == -direction.x || newDirection.y == -direction.y)
					) {
						setNextDirection(newDirection);
					}
					// å¦‚æœä¸‹ä¸€ä¸ªæ–¹å‘å’Œå½“å‰æ–¹å‘ä¸€è‡´åˆ™ä¸´æ—¶åŠ é€Ÿ
					if (newDirection.x === direction.x && newDirection.y === direction.y) {
						// æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
						if (speedTimeout) {
							clearTimeout(speedTimeout);
						}
						
						// è®¾ç½®ä¸´æ—¶åŠ é€Ÿ
						setIsTemporarySpeed(true);
						setGameSpeed(prev => prev - 100);
						
						// è®¾ç½®æ¢å¤å®šæ—¶å™¨
						const timeout = setTimeout(() => {
							setIsTemporarySpeed(false);
							// æ¢å¤åˆ°åŸºäºåˆ†æ•°çš„æ­£å¸¸é€Ÿåº¦
							const normalSpeed = 200 - 10 * speedLevel;
							// é•¿åº¦-1
							setSnake(prev => prev.slice(0, -1));
							// åŠ é€Ÿå¥–åŠ±
							setScore(prev => prev + speedLevel * 2);
							setGameSpeed(normalSpeed);
						}, 3000);
						
						setSpeedTimeout(timeout);
					}
				}

				// ç”Ÿæˆå¥–åŠ±é£Ÿç‰©
				const spawnBonusFood = () => {
					if (!isPlay || isPaused || gameOver) return;
					const newBonusFood = genFood();
					setBonusFood(newBonusFood);
					setTimeout(() => {
						setBonusFood(null);
					}, 5000);
				}
				
				useEffect(() => {
					if (!isPlay || isPaused || gameOver) return;
					const iniDelay = setTimeout(spawnBonusFood, 10000);
					const bonusInterval = setInterval(() => {
						if (!bonusFood) {
							spawnBonusFood();
						}
					}, 15000);
					return () => {
						clearTimeout(iniDelay);
						clearInterval(bonusInterval);
					}
				}, [isPlay, isPaused, gameOver, bonusFood])

				// æ¸¸æˆå¾ªç¯
				useEffect(() => {
					if (!isPlay || isPaused || gameOver) return;
					const gameLoop = setInterval(() => {
						moveSnake();
					}, gameSpeed);
					// æ¯ç§’é•¿åº¦ -1 
					const lengthLoop = setInterval(() => {
						setSnake(prev => prev.slice(0, -1));
					}, 1000);
					return () => {
						clearInterval(gameLoop);
						clearInterval(lengthLoop);
					}
				}, [isPlay, isPaused, gameOver, gameSpeed, moveSnake])

				// é€Ÿåº¦è°ƒæ•´
				useEffect(() => {
					if (!isPlay || isPaused || gameOver || isTemporarySpeed) return;
					increaseSpeed(score / 50 + 1);
				}, [score, isTemporarySpeed])

				// æ¸…ç†å®šæ—¶å™¨
				useEffect(() => {
					return () => {
						if (speedTimeout) {
							clearTimeout(speedTimeout);
						}
					};
				}, [speedTimeout]);

				// æ–¹å‘æ§åˆ¶ç›‘å¬
				useEffect(() => {
					const handleKeyDown = (e) => {
						if (!isPlay || gameOver) return;
						switch(e.key) {
							case 'ArrowUp':
							case 'w':
							case 'W':
								handleDirectionChange({x: 0, y: -1});
								break;
							case 'ArrowDown':
							case 's':
							case 'S':
								handleDirectionChange({x: 0, y: 1});
								break;
							case 'ArrowLeft':
							case 'a':
							case 'A':
								handleDirectionChange({x: -1, y: 0});
								break;
							case 'ArrowRight':
							case 'd':
							case 'D':
								handleDirectionChange({x: 1, y: 0});
								break;
						case ' ': // ç©ºæ ¼é”®
								isPaused ? resumeGame() : pauseGame();
								break;
							default: break;
						}
					}
					window.addEventListener('keydown', handleKeyDown);
					return () => window.removeEventListener('keydown', handleKeyDown);
				}, [isPaused, isPlay, gameOver, direction, nextDirection]);

				const [touch, setTouch] = useState(null);
				const handleTouch = (e) => {
					if (!isPlay || gameOver) return;
					const touchS = e.touches[0];
					setTouch({x: touchS.clientX, y: touchS.clientY});
				}

				const handleTouchEnd = (e) => {
					if (!isPlay || gameOver || !touch) return;
					const touchEnd = e.changedTouches[0];
					const touchEndPos = {x: touchEnd.clientX, y: touchEnd.clientY};
					const dx = touchEndPos.x - touch.x;
					const dy = touchEndPos.y - touch.y;
					if (Math.abs(dx) > Math.abs(dy)) {
						dx > 0 ? handleDirectionChange({x: 1, y: 0}) : handleDirectionChange({x: -1, y: 0});
					} else {
						dy > 0 ? handleDirectionChange({x: 0, y: 1}) : handleDirectionChange({x: 0, y: -1});
					}
					setTouch(null);
				}

				// æ¸²æŸ“æ¸¸æˆ
				return (
					<div>
						{/* è¿”å›ä¸»é¡µæŒ‰é’® */}
						<div className="mb-4">
							<a href="index.html" className="inline-flex items-center px-3 py-1 bg-gradient-to-r from-pink-500 to-blue-500 text-white rounded-lg hover:opacity-90 transition-opacity text-sm">
								<i className="fas fa-arrow-left mr-1"></i>
								è¿”å›
							</a>
						</div>
						
						<div className="game-container">
							<h1 className="game-title animate__animated animate__fadeInDown">
								ğŸ è´ªåƒè›‡å¤§å†’é™©
							</h1>
							<p className="game-subtitle animate__animated animate__fadeInUp">
								æ§åˆ¶å°è›‡åƒé£Ÿç‰©ï¼Œé¿å¼€å¢™å£å’Œè‡ªå·±
							</p>
						{/* æ¸¸æˆçŠ¶æ€ */}
						<GameStatus 
							score={score}
							highScore={highScore}
							speedLevel={speedLevel}
							isTemporarySpeed={isTemporarySpeed}
						/>
						{/* æ¸¸æˆç½‘æ ¼ */}
						<div className="game-grid mb-3" onTouchStart={handleTouch} onTouchEnd={handleTouchEnd}>
							{renderGrid()}
							{snake.map((segment, index) => (
								<SnakeSegment 
									key={index}
									position={segment}
									size={CELL_SIZE}
									isHead={index === 0}
								/>
							))}
							{food && (
								<Food 
									position={food}
									size={CELL_SIZE}
									isBonus={false}
								/>
							)}
							{bonusFood && (
								<Food 
									position={bonusFood}
									size={CELL_SIZE}
									isBonus={true}
								/>
							)}
							{isPaused && (
								<div className="absolute inset-0 bg-black/50 flex justify-center items-center">
									<div className="bg-white rounded-xl p-4 shadow-lg">
										<h3 className="text-xl font-bold text-gray-800">æ¸¸æˆæš‚åœ</h3>
									</div>
								</div>
							)}
						</div>
						{/* æ¸¸æˆæ§åˆ¶ */}
						<div className="text-center">
							<GameControls
								isPlay={isPlay}
								onStart={startGame} 
								onPause={pauseGame} 
								onResume={resumeGame} 
								onRestart={restartGame}
							/>
						</div>
						{/* æ¸¸æˆç»“æŸ */}
						{gameOver && (
							<GameOverModal 
								score={score}
								highScore={highScore}
								onRestart={restartGame}
							/>
						)}
						{/* æ¸¸æˆæç¤º */}
						{/*
						<div className="text-center text-gray-600 text-sm mt-6">
							<p className="mb-2">ä½¿ç”¨é”®ç›˜ä¸Šçš„ç®­å¤´é”®æˆ–è€…WASDé”®æ§åˆ¶è›‡çš„ç§»åŠ¨æ–¹å‘ï¼Œåƒæ‰é£Ÿç‰©å¯ä»¥è·å¾—åˆ†æ•°å¹¶å¢é•¿</p>
							<p className="mb-2">è¿ç»­æŒ‰ç›¸åŒæ–¹å‘é”®å¯ä»¥è§¦å‘ä¸´æ—¶åŠ é€Ÿï¼ˆ3ç§’ï¼‰ï¼Œå¹¶è·å¾—é¢å¤–åˆ†æ•°å¥–åŠ±</p>
							<p className="mb-2">æŒ‰ç©ºæ ¼é”®å¯ä»¥æš‚åœ/ç»§ç»­æ¸¸æˆ</p>
						</div>*/}
						</div>
					</div>
				)
			}
			const root = ReactDOM.createRoot(document.getElementById('root'));
			root.render(<SnakeGame />);
		</script>
	</body>
</html>